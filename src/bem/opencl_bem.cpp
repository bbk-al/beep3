/*
* opencl_bem.cpp
*
*  Created on: 22 Sep 2010
*      Author: david
*/
#ifdef OPENCL

#include <cstring> // memcpy
#include <CL/opencl.h>
#include "../opencl/opencl_workblob.h"
#include "node_patch.h"
#include "local_integrations.h"
#include "opencl_bem_structs.h"
#include "opencl_bem.h"

// This include pulls in the OpenCL code as a
// hex dump, generated by "xxd -i". It defines 
// two vars:
//    unsigned int opencl_bem_kernels_cl_len;
//    unsigned char opencl_bem_kernels_cl[];
// which are hopefully self-explanatory...
#include "opencl_bem_kernels.cl.h"

BEM_Resources::BEM_Resources(PatchPtrList incoming_srcs,
        PatchPtrList incoming_targs,
        double incoming_kappa,
        LocalIntegrations* incoming_final_destination) : 
            stashed_source_patches(incoming_srcs),
            stashed_target_patches(incoming_targs),
            cmDevResults(NULL),
            cmDevSrcs(NULL),
            cmDevTargs(NULL),
            cmDevQuads(NULL),
            m_kernel(NULL)

{
    for (int ii=0; ii < NUM_EVENTS; ++ii)
    {
        m_events[ii] = NULL;
    }

    OpenCL_WorkBlob::auto_delete = true;

    // record where the output goes
    final_destination = incoming_final_destination;

    // record the various parms/sizes
    kappa = static_cast<cl_float>(incoming_kappa);

    num_sources = static_cast<cl_uint>(incoming_srcs->size());
    num_targs = static_cast<cl_uint>(incoming_targs->size());
    num_results = num_sources * num_targs;
    results_size = num_results * sizeof(OpenCL_LocalIntegrationResult);

    assert(num_sources > 0);
    assert(num_targs > 0);

    // count total number of quad points
    num_quads=0;
    for (PPList::const_iterator it=stashed_target_patches->begin(), end=stashed_target_patches->end(); it != end; ++it)
    {
        boost::shared_ptr<QuadList> qps = (**it).get_quadrature_points();
        num_quads += qps->size();
    }
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        boost::shared_ptr<QuadList> qps = (**it).get_qualocation_points();
        num_quads += qps->size();
    }
    
}

BEM_Resources::~BEM_Resources() {
    host_srcs.reset();
    host_targs.reset();
    host_quads.reset();
    //host_results.reset();

    if(cmDevResults) clReleaseMemObject(cmDevResults);
    if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
    if(cmDevTargs) clReleaseMemObject(cmDevTargs);
    if(cmDevQuads) clReleaseMemObject(cmDevQuads);

    if(m_kernel) clReleaseKernel(m_kernel);
    
    for (int ii=0; ii < NUM_EVENTS; ++ii)
    {
        if(m_events[ii]) clReleaseEvent(m_events[ii]);
    }

    
}

const unsigned char* BEM_Resources::get_opencl_source() { return static_cast<const unsigned char*>(opencl_bem_kernels_cl); };

size_t BEM_Resources::device_mem_reqd() const
{
    size_t total=0;
    total += results_size;
    total += sizeof(OpenCL_QuadPoint)*num_quads;
    total += sizeof(OpenCL_NodePatch)*num_sources;
    total += sizeof(OpenCL_NodePatch)*num_targs;
    return total;
}

void BEM_Resources::allocate(const cl_context& ocl_gpu_context, const cl_program& ocl_program)
{
    try {
        init_OpenCL_structs();
        allocate_device_mem(ocl_gpu_context);
        init_kernel(ocl_gpu_context, ocl_program);
    }
    catch (AllocationException)
    {
        // cleanup any memory allocated so far
        if(cmDevResults) clReleaseMemObject(cmDevResults);
        if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
        if(cmDevTargs) clReleaseMemObject(cmDevTargs);
        if(cmDevQuads) clReleaseMemObject(cmDevQuads);

        // rethrow- handler should stop trying to enqueue things for a while!
        // (should retry to allocate this object in next iteration of do_work loop.)
        throw;
    }
}

bool BEM_Resources::finished() const
{
    // find out if the kernel event has completed
    cl_int retval;
    cl_int err = clGetEventInfo(m_events[NUM_EVENTS-1], CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), static_cast<void*>(&retval), NULL);
    if(err != CL_SUCCESS)
    {
        std::cout << "GetEventInfo failed with: " << err << std::endl;
    }
    assert(err == CL_SUCCESS);

    // handle errors
    if (retval < 0)
    {
        std::cout << "BEM_Resources::finished detected an event failed: " << retval << std::endl;
        throw std::exception();
    }
    
    return retval == CL_COMPLETE;
}

void BEM_Resources::copy_out_results() {
/*    for (size_t idx=0; idx < num_results; ++idx)
    {
        LocalIntegrations& lint = final_destination[idx];
        const OpenCL_LocalIntegrationResult& ocl_lint = host_results[idx];
        lint.Apt = ocl_lint.Apt;
        lint.Bpt = ocl_lint.Bpt;
        lint.Cpt = ocl_lint.Cpt;
        lint.Dpt = ocl_lint.Dpt;
        lint.src_global_idx = ocl_lint.src_global_idx;
        lint.targ_global_idx = ocl_lint.targ_global_idx;
    }
    return;
    */
}

void BEM_Resources::enqueue(cl_command_queue& ocl_queue)
{
    // Launch kernel
    ////printf("clEnqueueNDRangeKernel...");
    //std::cout << std::flush;

    //std::cout << szGlobalWorkSize << std::endl;
    size_t szGlobalWorkSize[2];
    size_t szLocalWorkSize[2];
    szLocalWorkSize[0] = static_cast<size_t>(xdim);
    szLocalWorkSize[1] = static_cast<size_t>(ydim);
    szGlobalWorkSize[0] = szLocalWorkSize[0] * static_cast<size_t>(ceil(static_cast<double>(num_sources) / szLocalWorkSize[0]));
    szGlobalWorkSize[1] = szLocalWorkSize[1] * static_cast<size_t>(ceil(static_cast<double>(num_targs) / szLocalWorkSize[1]));

    assert(szGlobalWorkSize[0] > 0);
    assert(szGlobalWorkSize[1] > 0);

    int err;
    err = clEnqueueNDRangeKernel(ocl_queue, m_kernel, 2, NULL, szGlobalWorkSize, szLocalWorkSize, 0, NULL, &(m_events[0]));
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clEnqueueNDRangeKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    ////printf("clEnqueueReadBuffer...");
    err = clEnqueueReadBuffer(ocl_queue, cmDevResults, CL_FALSE, 0, results_size, final_destination, 1, m_events, &(m_events[1]));
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clEnqueueReadBuffer, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    return;
}

void BEM_Resources::init_OpenCL_structs()
{

    //std::cout << "Quad size: " << num_quads * sizeof(OpenCL_QuadPoint) << std::endl;

    // allocate host memory for OpenCL structs
    host_srcs = boost::shared_array<OpenCL_NodePatch>(new OpenCL_NodePatch[num_sources]);
    host_targs = boost::shared_array<OpenCL_NodePatch>(new OpenCL_NodePatch[num_targs]);
    host_quads = boost::shared_array<OpenCL_QuadPoint>(new OpenCL_QuadPoint[num_quads]);
    //host_results = boost::shared_array<OpenCL_LocalIntegrationResult>(new OpenCL_LocalIntegrationResult[num_results]);

    // TODO:: throw exception if mallocs fail
    assert(host_srcs.get() != NULL);
    assert(host_targs.get() != NULL);
    assert(host_quads.get() != NULL);
    //assert(host_results.get() != NULL);
    
    assert(sizeof(OpenCL_QuadPoint) == QuadPoint::num_bytes);

    unsigned int tctr=0;
    unsigned int qctr=0;
    for (PPList::const_iterator it=stashed_target_patches->begin(), end=stashed_target_patches->end(); it != end; ++it)
    {
        const BasicNodePatch& np = **it;
        boost::shared_ptr<QuadList> qps = np.get_quadrature_points();
        OpenCL_NodePatch& ocl_targ = host_targs[tctr++];
        ocl_targ.idx = static_cast<cl_uint>(np.get_idx());
        ocl_targ.inverse_dielectric_ratio = static_cast<cl_float>(1.0 / np.get_dielectric_ratio());
        ocl_targ.first_quad_idx = static_cast<cl_uint>(qctr);
        ocl_targ.num_quad_points = static_cast<cl_uint>(qps->size());
        for (QuadList::const_iterator qit=qps->begin(), qend=qps->end(); qit != qend; ++qit)
        {
            const QuadPoint& np_qp = *qit;
            std::memcpy(&(host_quads[qctr++]), &np_qp, sizeof(OpenCL_QuadPoint));
/*            OpenCL_QuadPoint& ocl_qp = host_quads[qctr++];
            ocl_qp.ptx = static_cast<cl_float>(np_qp.x);
            ocl_qp.pty = static_cast<cl_float>(np_qp.y);
            ocl_qp.ptz = static_cast<cl_float>(np_qp.z);
            ocl_qp.nx = static_cast<cl_float>(np_qp.normal.x);
            ocl_qp.ny = static_cast<cl_float>(np_qp.normal.y);
            ocl_qp.nz = static_cast<cl_float>(np_qp.normal.z);
            ocl_qp.weight = static_cast<cl_float>(np_qp.weight);*/
        }
    }

    unsigned int sctr=0;
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        const BasicNodePatch& snp = **it;
        OpenCL_NodePatch& ocl_src = host_srcs[sctr++];
        ocl_src.idx = static_cast<cl_uint>(snp.get_idx());
        ocl_src.inverse_dielectric_ratio = static_cast<cl_float>(1.0 / snp.get_dielectric_ratio());
        ocl_src.first_quad_idx = static_cast<cl_uint>(qctr);

        boost::shared_ptr<QuadList> qps = snp.get_qualocation_points();
        ocl_src.num_quad_points = static_cast<cl_uint>(qps->size());
        for (QuadList::const_iterator qit=qps->begin(), qend=qps->end(); qit != qend; ++qit)
        {
            const QuadPoint& np_qp = *qit;
            std::memcpy(&(host_quads[qctr++]), &np_qp, sizeof(OpenCL_QuadPoint));
            
/*          OpenCL_QuadPoint& ocl_qp = host_quads[qctr++];
            ocl_qp.ptx = static_cast<cl_float>(np_qp.x);
            ocl_qp.pty = static_cast<cl_float>(np_qp.y);
            ocl_qp.ptz = static_cast<cl_float>(np_qp.z);
            ocl_qp.nx = static_cast<cl_float>(np_qp.normal.x);
            ocl_qp.ny = static_cast<cl_float>(np_qp.normal.y);
            ocl_qp.nz = static_cast<cl_float>(np_qp.normal.z);
            ocl_qp.weight = static_cast<cl_float>(np_qp.area / snp.get_bezier_area());*/
        }
    }

    return;

}

void BEM_Resources::allocate_device_mem(const cl_context ocl_context)
{

    ////printf("Allocating device memory...");
    int error;
    cmDevResults = clCreateBuffer(ocl_context, CL_MEM_READ_WRITE, results_size, NULL, &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevQuads = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_QuadPoint)*num_quads, host_quads.get(), &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevSrcs = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_NodePatch)*num_sources, host_srcs.get(), &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevTargs = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_NodePatch)*num_targs, host_targs.get(), &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    ////printf("done\n");
    return;
}

void BEM_Resources::init_kernel(const cl_context& ocl_context,
                const cl_program& ocl_program)
{
    int err;
    // Create the kernel
    ////printf("clCreateKernel (BEM_kernels)...");
    m_kernel = clCreateKernel(ocl_program, "BEM_kernels", &err);
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clCreateKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    // Set the Argument values
    ////printf("clSetKernelArg...");
    err  = clSetKernelArg(m_kernel, 0, sizeof(cl_mem), (void*)&cmDevSrcs);
    err |= clSetKernelArg(m_kernel, 1, sizeof(cl_mem), (void*)&cmDevTargs);
    err |= clSetKernelArg(m_kernel, 2, sizeof(cl_mem), (void*)&cmDevQuads);
    err |= clSetKernelArg(m_kernel, 3, sizeof(cl_mem), (void*)&cmDevResults);
    err |= clSetKernelArg(m_kernel, 4, sizeof(cl_uint), (void*)&num_sources);
    err |= clSetKernelArg(m_kernel, 5, sizeof(cl_uint), (void*)&num_targs);
    err |= clSetKernelArg(m_kernel, 6, sizeof(cl_uint), (void*)&num_quads);
    err |= clSetKernelArg(m_kernel, 7, sizeof(cl_float), (void*)&kappa);
    ////printf("done\n");
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clSetKernelArg, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }

    return;
}

BEM_OnDemand_Resources::BEM_OnDemand_Resources(PatchPtrList incoming_srcs,
                                                PatchPtrList incoming_targs,
                                                double incoming_kappa,
                                                const double* incoming_f,
                                                const double* incoming_h,
                                                double* output_f,
                                                double* output_h,
                                                bool auto_del,
                                                boost::mutex *results_mutex) :
                                                    stashed_source_patches(incoming_srcs),
                                                    stashed_target_patches(incoming_targs),
                                                    cmDevBlockResults(NULL),
                                                    cmDevResults(NULL),
                                                    cmDevFH(NULL),
                                                    cmDevSrcs(NULL),
                                                    cmDevTargs(NULL),
                                                    cmDevQuads(NULL),
                                                    m_kernel(NULL),
                                                    m_blk_results_kernel(NULL)

{
    
    for (int ii=0; ii < NUM_EVENTS; ++ii)
    {
        m_events[ii] = NULL;
    }

    OpenCL_WorkBlob::auto_delete = auto_del;

    // record where the output goes
    final_destinations_f = output_f;
    final_destinations_h = output_h;
    results_mutex_ptr = results_mutex;

    num_sources = static_cast<uint>(incoming_srcs->size());
    num_targs = static_cast<uint>(incoming_targs->size());

    assert(num_sources > 0);
    assert(num_targs > 0);

    // record the various parms/sizes
    kappa = static_cast<cl_float>(incoming_kappa);

    stashed_incoming_f = incoming_f;
    stashed_incoming_h = incoming_h;

    szLocalWorkSize[0] = static_cast<size_t>(xdim);
    szLocalWorkSize[1] = static_cast<size_t>(ydim);
    szGlobalWorkSize[0] = szLocalWorkSize[0] * static_cast<size_t>(ceil(static_cast<double>(num_sources) / szLocalWorkSize[0]));
    szGlobalWorkSize[1] = szLocalWorkSize[1] * static_cast<size_t>(ceil(static_cast<double>(num_targs) / szLocalWorkSize[1]));

    assert(szGlobalWorkSize[0] > 0);
    assert(szGlobalWorkSize[1] > 0);

    block_results_size = sizeof(cl_float2)*szGlobalWorkSize[0]*szGlobalWorkSize[1]/szLocalWorkSize[1];

    // count total number of quad points
    num_quads=0;
    for (PPList::const_iterator it=stashed_target_patches->begin(), end=stashed_target_patches->end(); it != end; ++it)
    {
        boost::shared_ptr<QuadList> qps = (**it).get_quadrature_points();
        num_quads += qps->size();
    }
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        boost::shared_ptr<QuadList> qps = (**it).get_qualocation_points();
        num_quads += qps->size();
    }
   
}

BEM_OnDemand_Resources::~BEM_OnDemand_Resources() {

    if(m_blk_results_kernel) clReleaseKernel(m_blk_results_kernel);
    for (int ii=0; ii < NUM_EVENTS; ++ii)
    {
        if(m_events[ii]) clReleaseEvent(m_events[ii]);
    }
    if(m_kernel) clReleaseKernel(m_kernel);

    if(cmDevBlockResults) clReleaseMemObject(cmDevBlockResults);
    if(cmDevResults) clReleaseMemObject(cmDevResults);
    if(cmDevFH) clReleaseMemObject(cmDevFH);
    if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
    if(cmDevTargs) clReleaseMemObject(cmDevTargs);
    if(cmDevQuads) clReleaseMemObject(cmDevQuads);

}

const unsigned char* BEM_OnDemand_Resources::get_opencl_source() { return static_cast<const unsigned char*>(opencl_bem_kernels_cl); };

size_t BEM_OnDemand_Resources::device_mem_reqd() const
{
    size_t total=0;
    assert(num_quads > 0);
    total += sizeof(OpenCL_QuadPoint)*num_quads;
    total += sizeof(OpenCL_NodePatch)*num_sources;
    total += sizeof(OpenCL_NodePatch)*num_targs;
    total += block_results_size; // block-level results
    total += sizeof(cl_float2)*num_sources; // results
    total += sizeof(cl_float)*num_targs; // fh vals
   
    return total;
}
 

void BEM_OnDemand_Resources::allocate(const cl_context& ocl_gpu_context, const cl_program& ocl_program)
{
    try {
        init_OpenCL_structs();
        allocate_device_mem(ocl_gpu_context);
        init_kernel(ocl_gpu_context, ocl_program);
    }
    catch (AllocationException)
    {
        // cleanup any memory allocated so far
        if(cmDevBlockResults) clReleaseMemObject(cmDevBlockResults);
        if(cmDevResults) clReleaseMemObject(cmDevResults);
        if(cmDevFH) clReleaseMemObject(cmDevFH);
        if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
        if(cmDevTargs) clReleaseMemObject(cmDevTargs);
        if(cmDevQuads) clReleaseMemObject(cmDevQuads);

        // rethrow- handler should stop trying to enqueue things for a while!
        // (should retry to allocate this object in next iteration of do_work loop.)
        throw;
    }
}

bool BEM_OnDemand_Resources::finished() const
{
    // find out if the kernel event has completed
    cl_int retval;
    cl_int err = clGetEventInfo(m_events[NUM_EVENTS-1], CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), static_cast<void*>(&retval), NULL);
    if(err != CL_SUCCESS)
    {
        std::cout << "GetEventInfo failed with: " << err << std::endl;
    }
    assert(err == CL_SUCCESS);
    
    // handle errors
    if (retval < 0)
    {
        std::cout << "BEM_OnDemand_Resources::finished detected an event failed: " << retval << std::endl;
        throw std::exception();
    }

    return retval == CL_COMPLETE;
}

inline void BEM_OnDemand_Resources::copy_out_results() {

    // thread-safety first!
    // if the results mutex pointer was passed in, then obtain a
    // lock before modifying the results memory
    boost::scoped_ptr<boost::mutex::scoped_lock> lck_ptr;
    if (results_mutex_ptr != NULL) {
        lck_ptr.reset(new boost::mutex::scoped_lock(*results_mutex_ptr));
    }

    // now can commit the GPU results to proper memory
    for (unsigned int ii=0; ii < num_sources; ++ii)
    {
        unsigned int idx = (*stashed_source_patches)[ii]->get_idx();
        //const OpenCL_NodePatch& src = host_srcs[ii];
        //std::cout << "Adding (" << src.idx << ") " << host_results[ii].x << " " << host_results[ii].y << std::endl;
        final_destinations_f[idx] += static_cast<double>(host_results[ii].x);
        final_destinations_h[idx] += static_cast<double>(host_results[ii].y);
    }
    return;
}

void BEM_OnDemand_Resources::enqueue(cl_command_queue& ocl_queue)
{
    // Launch kernel
    //printf("clEnqueueNDRangeKernel...");
    //std::cout << std::flush;

    int err;
    err = clEnqueueNDRangeKernel(ocl_queue, m_kernel, 2, NULL, szGlobalWorkSize, szLocalWorkSize, 0, NULL, &(m_events[0]));
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clEnqueueNDRangeKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    size_t blk_results_kernel_width = BEM_BLOCK_RESULTS_COLLECTION_WIDTH;
    size_t blk_results_total_threads = blk_results_kernel_width * static_cast<size_t>(ceil(static_cast<double>(num_sources) / blk_results_kernel_width));
    //printf("clEnqueueNDRangeKernel (blk_results_kernel [%d]) ... ", blk_results_total_threads);
    //std::cout << std::flush;

    err = clEnqueueNDRangeKernel(ocl_queue, m_blk_results_kernel, 1, NULL, &blk_results_total_threads, &blk_results_kernel_width, 1, m_events, &(m_events[1]));
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clEnqueueNDRangeKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    //printf("clEnqueueReadBuffer...");
    err = clEnqueueReadBuffer(ocl_queue, cmDevResults, CL_FALSE, 0, sizeof(cl_float2)*num_sources, host_results.get(), 2, m_events, &(m_events[2]));
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clEnqueueReadBuffer, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    return;
}

void BEM_OnDemand_Resources::init_OpenCL_structs()
{

    // allocate host memory for OpenCL structs
    host_srcs = boost::shared_array<OpenCL_NodePatch>(new OpenCL_NodePatch[num_sources]);
    host_targs = boost::shared_array<OpenCL_NodePatch>(new OpenCL_NodePatch[num_targs]);
    host_quads = boost::shared_array<OpenCL_QuadPoint>(new OpenCL_QuadPoint[num_quads]);
    host_results = boost::shared_array<cl_float2>(new cl_float2[num_sources]);
    host_fh = boost::shared_array<cl_float>(new cl_float[num_targs*2]);

    // TODO:: throw exception if mallocs fail
    assert(host_srcs.get() != NULL);
    assert(host_targs.get() != NULL);
    assert(host_quads.get() != NULL);
    assert(host_results.get() != NULL);
    assert(host_fh.get() != NULL);
    
    assert(sizeof(OpenCL_QuadPoint) == QuadPoint::num_bytes);

    for (unsigned int targ_ctr=0; targ_ctr < num_targs; ++targ_ctr) {
        unsigned int targ_idx = (*stashed_target_patches)[targ_ctr]->get_idx();
        host_fh[targ_ctr] = static_cast<cl_float>(stashed_incoming_f[targ_idx]);
        host_fh[targ_ctr+num_targs] = static_cast<cl_float>(stashed_incoming_h[targ_idx]);
    }
    
    unsigned int qctr=0;
    unsigned int tctr=0;
    for (PPList::const_iterator it=stashed_target_patches->begin(), end=stashed_target_patches->end(); it != end; ++it)
    {
        const BasicNodePatch& np = **it;
        boost::shared_ptr<QuadList> qps = np.get_quadrature_points();
        OpenCL_NodePatch& ocl_targ = host_targs[tctr++];
        
        ocl_targ.idx = static_cast<cl_uint>(np.get_idx());
        ocl_targ.inverse_dielectric_ratio = static_cast<cl_float>(1.0 / np.get_dielectric_ratio());
        ocl_targ.first_quad_idx = static_cast<cl_uint>(qctr);
        ocl_targ.num_quad_points = static_cast<cl_uint>(qps->size());
        for (QuadList::const_iterator qit=qps->begin(), qend=qps->end(); qit != qend; ++qit)
        {
            const QuadPoint& np_qp = *qit;
            std::memcpy(&(host_quads[qctr++]), &np_qp, sizeof(OpenCL_QuadPoint));
//             OpenCL_QuadPoint& ocl_qp = host_quads[qctr++];
//             ocl_qp.ptx = static_cast<cl_float>(np_qp.x);
//             ocl_qp.pty = static_cast<cl_float>(np_qp.y);
//             ocl_qp.ptz = static_cast<cl_float>(np_qp.z);
//             ocl_qp.nx = static_cast<cl_float>(np_qp.normal.x);
//             ocl_qp.ny = static_cast<cl_float>(np_qp.normal.y);
//             ocl_qp.nz = static_cast<cl_float>(np_qp.normal.z);
//             ocl_qp.weight = static_cast<cl_float>(np_qp.weight);
        }
    }
    unsigned int sctr=0;
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        const BasicNodePatch& snp = **it;
        boost::shared_ptr<QuadList> qps = snp.get_qualocation_points();
        OpenCL_NodePatch& ocl_src = host_srcs[sctr++];
        
        ocl_src.idx = static_cast<cl_uint>(snp.get_idx());
        ocl_src.inverse_dielectric_ratio = static_cast<cl_float>(1.0 / snp.get_dielectric_ratio());
        ocl_src.first_quad_idx = static_cast<cl_uint>(qctr);
        ocl_src.num_quad_points = static_cast<cl_uint>(qps->size());
        for (QuadList::const_iterator qit=qps->begin(), qend=qps->end(); qit != qend; ++qit)
        {
            const QuadPoint& np_qp = *qit;
            std::memcpy(&(host_quads[qctr++]), np_qp.bytes(), sizeof(OpenCL_QuadPoint));
//             OpenCL_QuadPoint& ocl_qp = host_quads[qctr++];
//             ocl_qp.ptx = static_cast<cl_float>(np_qp.x);
//             ocl_qp.pty = static_cast<cl_float>(np_qp.y);
//             ocl_qp.ptz = static_cast<cl_float>(np_qp.z);
//             ocl_qp.nx = static_cast<cl_float>(np_qp.normal.x);
//             ocl_qp.ny = static_cast<cl_float>(np_qp.normal.y);
//             ocl_qp.nz = static_cast<cl_float>(np_qp.normal.z);
//             ocl_qp.weight = static_cast<cl_float>(np_qp.area / snp.get_bezier_area());
         }
    }
    
    return;

}

void BEM_OnDemand_Resources::allocate_device_mem(const cl_context ocl_context)
{
    //printf("Allocating device memory...");
    int error;
    cmDevBlockResults = clCreateBuffer(ocl_context, CL_MEM_READ_WRITE, block_results_size, NULL, &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }
    cmDevResults = clCreateBuffer(ocl_context, CL_MEM_READ_WRITE, sizeof(cl_float2)*num_sources, NULL, &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevFH = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(cl_float)*num_targs*2, host_fh.get(), &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevQuads = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_QuadPoint)*num_quads, host_quads.get(), &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevSrcs = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_NodePatch)*num_sources, host_srcs.get(), &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevTargs = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_NodePatch)*num_targs, host_targs.get(), &error);
    if (error != CL_SUCCESS) {
        //printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    //printf("done\n");
    
    //std::cout << "Total device memory alloc'd: " << block_results_size << " " << sizeof(cl_float2)*num_sources << " " << sizeof(OpenCL_NodePatch)*num_targs << " " << sizeof(OpenCL_QuadPoint)*num_quads << "\n";
    
    return;
}

void BEM_OnDemand_Resources::init_kernel(const cl_context& ocl_context,
                const cl_program& ocl_program)
{
    int err;
    // Create the kernel
    //printf("clCreateKernel (BEM_kernels)...");
    m_kernel = clCreateKernel(ocl_program, "BEM_kernels_instant", &err);
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clCreateKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    // Set the Argument values
    //printf("clSetKernelArg...");
    err  = clSetKernelArg(m_kernel, 0, sizeof(cl_mem), (void*)&cmDevFH);
    err  = clSetKernelArg(m_kernel, 1, sizeof(cl_mem), (void*)&cmDevSrcs);
    err |= clSetKernelArg(m_kernel, 2, sizeof(cl_mem), (void*)&cmDevTargs);
    err |= clSetKernelArg(m_kernel, 3, sizeof(cl_mem), (void*)&cmDevQuads);
    err |= clSetKernelArg(m_kernel, 4, sizeof(cl_mem), (void*)&cmDevBlockResults);
    err |= clSetKernelArg(m_kernel, 5, sizeof(cl_uint), (void*)&num_sources);
    err |= clSetKernelArg(m_kernel, 6, sizeof(cl_uint), (void*)&num_targs);
    err |= clSetKernelArg(m_kernel, 7, sizeof(cl_uint), (void*)&num_quads);
    err |= clSetKernelArg(m_kernel, 8, sizeof(cl_float), (void*)&kappa);
    err |= clSetKernelArg(m_kernel, 9, sizeof(cl_float2)*xdim*ydim, NULL);
    //printf("done\n");
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clSetKernelArg, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }

    // Create the block-results collection kernel
    //printf("clCreateKernel (processBEMBlockResults)...");
    m_blk_results_kernel = clCreateKernel(ocl_program, "processBEMBlockResults", &err);
    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clCreateKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    // Set the Argument values
    //printf("clSetKernelArg...");
    blk_xdim = szGlobalWorkSize[0];
    blk_ydim = szGlobalWorkSize[1] / szLocalWorkSize[1];

    err  = clSetKernelArg(m_blk_results_kernel, 0, sizeof(cl_mem), (void*)&cmDevBlockResults);
    err |= clSetKernelArg(m_blk_results_kernel, 1, sizeof(cl_mem), (void*)&cmDevResults);
    err |= clSetKernelArg(m_blk_results_kernel, 2, sizeof(cl_uint), (void*)&num_sources);
    err |= clSetKernelArg(m_blk_results_kernel, 3, sizeof(cl_uint), (void*)&blk_xdim);
    err |= clSetKernelArg(m_blk_results_kernel, 4, sizeof(cl_uint), (void*)&blk_ydim);

    if (err != CL_SUCCESS)
    {
        //printf("Error %d in clSetKernelArg, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    //printf("done\n");

    return;
}

// This sorts out the singular node patch integrals
SingularBEM::SingularBEM(PatchPtrList incoming_srcs,
        double incoming_kappa,
        LocalIntegrations* incoming_final_destination) : 
            stashed_source_patches(incoming_srcs),
            cmDevResults(NULL),
            cmDevSrcs(NULL),
            cmDevQuads(NULL),
            m_kernel(NULL)

{
    OpenCL_WorkBlob::auto_delete = true;

    // record where the output goes
    final_destination = incoming_final_destination;

    // record the various parms/sizes
    kappa = static_cast<cl_float>(incoming_kappa);

    num_patches = static_cast<cl_uint>(incoming_srcs->size());
    num_results = num_patches;
    results_size = num_results * sizeof(OpenCL_LocalIntegrationResult);

    assert(num_patches > 0);

    // count total number of quad points
    num_quads=0;
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        boost::shared_ptr<QuadList> qps = (**it).get_galerkin_points();
        qp_cache.push_back(qps);
        num_quads += qps->size();
    }
}

SingularBEM::~SingularBEM() {
    host_srcs.reset();
    host_quads.reset();
    //host_results.reset();

    if(cmDevResults) clReleaseMemObject(cmDevResults);
    if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
    if(cmDevQuads) clReleaseMemObject(cmDevQuads);

    if(m_kernel) clReleaseKernel(m_kernel);
    for (int ii=0; ii < NUM_EVENTS; ++ii)
    {
        if(m_events[ii]) clReleaseEvent(m_events[ii]);
    }
    
}

const unsigned char* SingularBEM::get_opencl_source() { return static_cast<const unsigned char*>(opencl_bem_kernels_cl); };

size_t SingularBEM::device_mem_reqd() const
{
    size_t total=0;
    total += results_size;
    total += sizeof(OpenCL_QuadPoint)*num_quads;
    total += sizeof(OpenCL_NodePatch)*num_patches;
    return total;
}

void SingularBEM::allocate(const cl_context& ocl_gpu_context, const cl_program& ocl_program)
{
    try {
        init_OpenCL_structs();
        allocate_device_mem(ocl_gpu_context);
        init_kernel(ocl_gpu_context, ocl_program);
    }
    catch (AllocationException)
    {
        // cleanup any memory allocated so far
        if(cmDevResults) clReleaseMemObject(cmDevResults);
        if(cmDevSrcs) clReleaseMemObject(cmDevSrcs);
        if(cmDevQuads) clReleaseMemObject(cmDevQuads);

        // rethrow- handler should stop trying to enqueue things for a while!
        // (should retry to allocate this object in next iteration of do_work loop.)
        throw;
    }
}

bool SingularBEM::finished() const
{
    // find out if the kernel event has completed
    cl_int retval;
    cl_int err = clGetEventInfo(m_events[NUM_EVENTS-1], CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(cl_int), static_cast<void*>(&retval), NULL);
    assert(err == CL_SUCCESS);
    
    // handle errors
    if (retval < 0)
    {
        std::cout << "SingularBEM::finished detected an event failed: " << retval << std::endl;
        throw std::exception();
    }
    
    return retval == CL_COMPLETE;
}

void SingularBEM::copy_out_results() {
    /*
     for (size_t idx=0; idx < num_results; ++idx)
     {
         LocalIntegrations& lint = final_destination[idx];
         const OpenCL_LocalIntegrationResult& ocl_lint = host_results[idx];
         lint.Apt = ocl_lint.Apt;
         lint.Bpt = ocl_lint.Bpt;
         lint.Cpt = ocl_lint.Cpt;
         lint.Dpt = ocl_lint.Dpt;
         lint.src_global_idx = ocl_lint.src_global_idx;
         lint.targ_global_idx = ocl_lint.targ_global_idx;
     }
    return;
*/
}

void SingularBEM::enqueue(cl_command_queue& ocl_queue)
{
    static size_t ctr=0;
    // Launch kernel
    ////printf("clEnqueueNDRangeKernel...");
    //std::cout << std::flush;

    //std::cout << szGlobalWorkSize << std::endl;
    size_t szGlobalWorkSize[1];
    size_t szLocalWorkSize[1];
    szLocalWorkSize[0] = static_cast<size_t>(xdim);
    szGlobalWorkSize[0] = szLocalWorkSize[0] * static_cast<size_t>(ceil(static_cast<double>(num_patches) / szLocalWorkSize[0]));

    assert(szGlobalWorkSize[0] > 0);

    int err;
    err = clEnqueueNDRangeKernel(ocl_queue, m_kernel, 1, NULL, szGlobalWorkSize, szLocalWorkSize, 0, NULL, &(m_events[0]));
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clEnqueueNDRangeKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    ////printf("clEnqueueReadBuffer...");
    err = clEnqueueReadBuffer(ocl_queue, cmDevResults, CL_FALSE, 0, results_size, final_destination, 1, m_events, &(m_events[1]));
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clEnqueueReadBuffer, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    return;
}

void SingularBEM::init_OpenCL_structs()
{

    //std::cout << "Quad size: " << num_quads * sizeof(OpenCL_QuadPoint) << std::endl;

    // allocate host memory for OpenCL structs
    host_srcs = boost::shared_array<OpenCL_NodePatch>(new OpenCL_NodePatch[num_patches]);
    host_quads = boost::shared_array<OpenCL_QuadPoint>(new OpenCL_QuadPoint[num_quads]);
//    host_results = boost::shared_array<OpenCL_LocalIntegrationResult>(new OpenCL_LocalIntegrationResult[num_results]);

    // TODO:: throw exception if mallocs fail
    assert(host_srcs.get() != NULL);
    assert(host_quads.get() != NULL);
//    assert(host_results.get() != NULL);

    unsigned int sctr=0;
    unsigned int qctr=0;
    for (PPList::const_iterator it=stashed_source_patches->begin(), end=stashed_source_patches->end(); it != end; ++it)
    {
        const BasicNodePatch& snp = **it;
        OpenCL_NodePatch& ocl_src = host_srcs[sctr++];
        ocl_src.idx = static_cast<cl_uint>(snp.get_idx());
        ocl_src.inverse_dielectric_ratio = static_cast<cl_float>(1.0 / snp.get_dielectric_ratio());
        ocl_src.first_quad_idx = static_cast<cl_uint>(qctr);

        boost::shared_ptr<QuadList> qps = snp.get_galerkin_points();
        ocl_src.num_quad_points = static_cast<cl_uint>(qps->size());
        for (QuadList::const_iterator qit=qps->begin(), qend=qps->end(); qit != qend; ++qit)
        {
            const QuadPoint& np_qp = *qit;
            std::memcpy(&(host_quads[qctr++]), &np_qp, sizeof(OpenCL_QuadPoint));
            
          /*OpenCL_QuadPoint& ocl_qp = host_quads[qctr++];
            ocl_qp.ptx = static_cast<cl_float>(np_qp.pt().x);
            ocl_qp.pty = static_cast<cl_float>(np_qp.pt().y);
            ocl_qp.ptz = static_cast<cl_float>(np_qp.pt().z);
            ocl_qp.nx = static_cast<cl_float>(np_qp.normal().x);
            ocl_qp.ny = static_cast<cl_float>(np_qp.normal().y);
            ocl_qp.nz = static_cast<cl_float>(np_qp.normal().z);
            ocl_qp.weight = static_cast<cl_float>(np_qp.weight());*/
        }
    }

    return;

}

void SingularBEM::allocate_device_mem(const cl_context ocl_context)
{

    ////printf("Allocating device memory...");
    int error;
    cmDevResults = clCreateBuffer(ocl_context, CL_MEM_READ_WRITE, results_size, NULL, &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevQuads = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_QuadPoint)*num_quads, host_quads.get(), &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    cmDevSrcs = clCreateBuffer(ocl_context, CL_MEM_COPY_HOST_PTR | CL_MEM_READ_ONLY, sizeof(OpenCL_NodePatch)*num_patches, host_srcs.get(), &error);
    if (error != CL_SUCCESS) {
        ////printf("Failed to create a device buffer, Error %d @ Line %u in file %s !!!\n\n", error, __LINE__, __FILE__);
        throw std::exception();
    }

    ////printf("done\n");
    return;
}

void SingularBEM::init_kernel(const cl_context& ocl_context,
                const cl_program& ocl_program)
{
    int err;
    // Create the kernel
    ////printf("clCreateKernel (BEM_kernels)...");
    m_kernel = clCreateKernel(ocl_program, "Singular_BEM_Kernels", &err);
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clCreateKernel, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }
    ////printf("done\n");

    // Set the Argument values
    ////printf("clSetKernelArg...");
    err  = clSetKernelArg(m_kernel, 0, sizeof(cl_mem), (void*)&cmDevSrcs);
    err |= clSetKernelArg(m_kernel, 1, sizeof(cl_mem), (void*)&cmDevQuads);
    err |= clSetKernelArg(m_kernel, 2, sizeof(cl_mem), (void*)&cmDevResults);
    err |= clSetKernelArg(m_kernel, 3, sizeof(cl_uint), (void*)&num_patches);
    err |= clSetKernelArg(m_kernel, 4, sizeof(cl_uint), (void*)&num_quads);
    err |= clSetKernelArg(m_kernel, 5, sizeof(cl_float), (void*)&kappa);
    ////printf("done\n");
    if (err != CL_SUCCESS)
    {
        ////printf("Error %d in clSetKernelArg, Line %u in file %s !!!\n\n", err, __LINE__, __FILE__);
        throw std::exception();
    }

    return;
}
#endif


